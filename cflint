#!/usr/bin/env python
#
# Copyright (c) 2009, Jesse Kempf
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# - Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
# - Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
# - Neither the names of the author nor the names of its contributors
#     may be used to endorse or promote products derived from this software
#     without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
#  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
#  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
#  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
#  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
#  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
#  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import collections
import optparse
import os
import re
import sys

def err(str):
	print >> sys.stderr, ("%s" % str)

class CFGroup(object):
	def __init__(self, file, name):
		self.file = file
		self.name = name

	def __str__(self):
		return "CFGroup '%s' defined in %s" % (self.name, self.file)

def parseCF(filename, file):
	mode = ''

	groups = []

	for line in file:
		line = line.strip()

		if line.startswith('groups:'):
			mode = 'G'
			line = line.replace('groups:', '')

		if mode is 'G':
			try:
				(gname, decl) = line.split('=')
				groups.append(CFGroup(filename, gname.strip()))
			except ValueError:
				# There are three possible reasons why the split failed:
				# 1: We've moved on to a new action, like editfiles
				# 2: We've hit a group-conditional statement
				# 3: We're in the middle of a multi-line class definition
				#
				# XXX: We do not yet take care of the instance where
				# 	there's a class-and-statement one liner like
				#	someclass:: newclass = ( TruthFunc(arg) ).
				if re.match(r'[a-zA-Z]+:(?!:)', line):
					mode = ''
				continue
		elif (line.startswith('DefineClasses') or
			line.startswith('ElseDefineClasses') or
			line.startswith('DefineInGroup')):
	
			if "'" in line:
				quot = "'"
			elif '"' in line:
				quot = '"'
			else:
				err("Warning: malformed line: %s" % line)

			(decl, groupnames, _) = line.split(quot)
			groupnames = groupnames.replace(quot, '')
			for gname in groupnames.split(':'):
				groups.append(CFGroup(filename, gname.strip()))
		elif 'define=' in line:
				# Conveniently enough, this covers the use of
				# both define= and elsedefine=, for obvious reasons.
				base_idx = line.find('define=')
				max_idx = line.find(' ', base_idx)

				if max_idx == -1:
					max_idx = line.find('\t', base_idx)

				if max_idx == -1:
			 		define = line[base_idx:]
				else:
					define = line[base_idx:max_idx]

				(_, groupnames) = define.split('=')
				for gname in groupnames.split(':'):
					groups.append(CFGroup(filename, gname.strip()))
	
	return groups

def main(opts, fnames):

	groups = [ parseCF(fname, file(fname)) for fname in fnames ]
	groups = reduce(list.__add__, groups)

	# Check for multiply-defined groups, which is an indicator that
	# CFEngine scripts might be trampling each other.
	groups_defined = collections.defaultdict(list)

	for g in groups:
		groups_defined[g.name].append(g)

	for k, v in groups_defined.iteritems():
		def_files = set([g.file for g in v])

		if len(def_files) > 1:
			print "Warning: Group %s has been declared in:" % k
			for f in def_files:
				print "\t%s" % f

if __name__ == '__main__':
	op = optparse.OptionParser(usage='%prog [options] <files>')
	(opts, args) = op.parse_args()

	try:
		(fnames) = args
	except ValueError:
		err("%s" % op.get_usage().strip())
		sys.exit(os.EX_USAGE)

	main(opts, fnames)
